using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Threading.Tasks.Dataflow;

namespace TestClassGenerator
{
    public class TestGenerator
    {
        private const int MaxConcurrentFileLoads = 5;
        private const int MaxConcurrentTestGenerations = 10;
        private const int MaxConcurrentFileWrites = 5;

        public async Task GenerateTestsAsync(IEnumerable<string> inputFiles, string outputDirectory)
        {
            // Блок записи файлов
            var writeBlock = new ActionBlock<(string testClass, string className)>(async tuple =>
            {
                var (testClass, className) = tuple;
                var outputFile = Path.Combine(outputDirectory, $"{className}Tests.cs");
                await Task.Run(() => File.WriteAllText(outputFile, testClass));
            }, new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = MaxConcurrentFileWrites });

            // Блок генерации тестовых классов
            var generateBlock = new ActionBlock<ClassDeclarationSyntax>(async classDeclaration =>
            {
                var testClass = GenerateTestClass(classDeclaration);
                await writeBlock.SendAsync((testClass, classDeclaration.Identifier.Text));
            }, new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = MaxConcurrentTestGenerations });

            // Блок загрузки и разбора файлов
            var loadBlock = new ActionBlock<string>(async filePath =>
            {
                var code = await Task.Run(() => File.ReadAllText(filePath));
                var compilationUnit = CSharpSyntaxTree.ParseText(code).GetCompilationUnitRoot();
                var classes = compilationUnit.DescendantNodes().OfType<ClassDeclarationSyntax>();
                foreach (var classDeclaration in classes)
                {
                    await generateBlock.SendAsync(classDeclaration);
                }
            }, new ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = MaxConcurrentFileLoads });

            // отправка файлов в loadBlock
            foreach (var file in inputFiles)
            {
                await loadBlock.SendAsync(file);
            }

            // Завершение цепочки
            loadBlock.Complete();
            await loadBlock.Completion;

            generateBlock.Complete();
            await generateBlock.Completion;

            writeBlock.Complete();
            await writeBlock.Completion;
        }

        private string GenerateTestClass(ClassDeclarationSyntax classDeclaration)
        {
            var className = classDeclaration.Identifier.Text;
            var methods = classDeclaration.Members.OfType<MethodDeclarationSyntax>();
            var testMethods = methods.Select(method => GenerateTestMethod(method)).ToList();

            var namespaceDeclaration = classDeclaration.FirstAncestorOrSelf<NamespaceDeclarationSyntax>();
            var namespaceName = namespaceDeclaration?.Name.ToString() ?? "GeneratedTests";

            var testClassBuilder = $@"
using NUnit.Framework;
using {namespaceName};

namespace {namespaceName}.Tests
{{
    [TestFixture]
    public class {className}Tests
    {{
        {string.Join(Environment.NewLine + "        ", testMethods)}
    }}
}}";
            return testClassBuilder;
        }

        private string GenerateTestMethod(MethodDeclarationSyntax method)
        {
            var methodName = method.Identifier.Text;
            var overloadIndex = GetMethodOverloadIndex(method);
            return $@"
        [Test]
        public void {methodName}{overloadIndex}Test()
        {{
            Assert.Fail(""autogenerated"");
        }}";
        }

        private int GetMethodOverloadIndex(MethodDeclarationSyntax method)
        {
            var methodsWithSameName = method.Parent.DescendantNodes()
                .OfType<MethodDeclarationSyntax>()
                .Where(m => m.Identifier.Text == method.Identifier.Text)
                .ToList();
            var index = methodsWithSameName.IndexOf(method);
            return index >= 0 ? index + 1 : 0;
        }
    }
}